\chapterimage{chapter_0.png}
\chapter{STL}

\begin{center}
    \pgfornament[width=0.36\linewidth,color=lsp]{88}
\end{center}

\begin{mybox1}
\textbf{备注}： 以c++14为标准
\end{mybox1}

\section{pair}
std::pair 是标准库中定义的一个类模板。用于将两个变量关联在一起，组成一个“对”，而且两个变量的数据类型可以是不同的。
\lstinputlisting[style=cpp]{code/stl/pair.cpp}

\section{vector}
std::vector 是 STL 提供的 内存连续的、可变长度 的数组（亦称列表）数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。
\lstinputlisting[style=cpp]{code/stl/vector.cpp}

\section{array}
std::array 是 STL 提供的 内存连续的、固定长度 的数组数据结构。其本质是对原生数组的直接封装。
\lstinputlisting[style=cpp]{code/stl/array.cpp}

\section{deque}
std::deque 是 STL 提供的 双端队列 数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。
\lstinputlisting[style=cpp]{code/stl/deque.cpp}

\section{list}
std::list 是 STL 提供的 双向链表 数据结构。能够提供线性复杂度的随机访问，以及常数复杂度的插入和删除。

list 的使用方法与 deque 基本相同，但是增删操作和访问的复杂度不同。此处列下特殊的(下列函数list提供了特别的实现以供使用):
\lstinputlisting[style=cpp]{code/stl/list.cpp}

\section{set / unordered\_set}
关于 unordered\_set 的哈希冲突，使用自定义哈希函数可以有效避免构造数据产生的大量哈希冲突，代码实现见本册附录。

set 是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。set 内部通常采用红黑树实现。平衡二叉树的特性使得 set 非常适合处理需要同时兼顾查找、插入与删除的情况。\\
和数学中的集合相似，set 中不会出现值相同的元素。如果需要有相同元素的集合，需要使用 multiset。multiset 的使用方法与 set 的使用方法基本相同。(当然也有unordered\_multiset)
\lstinputlisting[style=cpp]{code/stl/set.cpp}

\section{map / unordered\_map}
关于 unordered\_map 的哈希冲突，使用自定义哈希函数可以有效避免构造数据产生的大量哈希冲突，代码实现见本册附录。

map 是有序键值对容器，它的元素的键是唯一的。搜索、移除和插入操作拥有对数复杂度。map 通常实现为红黑树。multimap则允许有重复的Key值。(当然也有 unordered\_multimap)
\lstinputlisting[style=cpp]{code/stl/map.cpp}

\section{string}
std::string 是在标准库 <string>（注意不是 C 语言中的 <string.h> 库）中提供的一个类，本质上是 std::basic\_string<char> 的别称。

\lstinputlisting[style=cpp]{code/stl/string.cpp}

\section{stack}
STL 栈 (std::stack) 是一种后进先出 (Last In, First Out) 的容器适配器，仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。
\lstinputlisting[style=cpp]{code/stl/stack.cpp}

\section{queue}
STL 队列 (std::queue) 是一种先进先出 (First In, First Out) 的容器适配器，仅支持查询或删除第一个加入的元素（队首元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。
\lstinputlisting[style=cpp]{code/stl/queue.cpp}

\section{qriority\_queue}
默认容器为vector, 默认算子为 less, 也就是最大堆
\lstinputlisting[style=cpp]{code/stl/priority_queue.cpp}


\section{bitset}
std::bitset 是标准库中的一个存储 0/1 的大小不可变容器。严格来讲，它并不属于 STL。
\lstinputlisting[style=cpp]{code/stl/bitset.cpp}

\section{iterator}
\lstinputlisting[style=cpp]{code/stl/iterator.cpp}

\section{algorithm}

\subsection{Non-modifying sequence operations}

\begin{table}[!ht]
    \centering
    \caption{Non-modifying sequence operations}
    \renewcommand\arraystretch{1.3}
    \begin{tabular}{|l|l|}
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{all\_of} \hword{any\_of} \hword{none\_of} & checks if a predicate is \textbf{true} for all, any or none of the elements in a range \\ \hline
        \hword{for\_each} & 	applies a function to a range of elements \\ \hline
        \hword{count} \hword{count\_if} & returns the number of elements satisfying specific criteria \\ \hline
        \hword{mismatch} & finds the first position where two ranges differ \\ \hline
        \hword{find} \hword{find\_if} \hword{find\_if\_not} & 	finds the first element satisfying specific criteria \\ \hline
        \hword{find\_end} &  finds the last sequence of elements in a certain range \\ \hline
        \hword{find\_first\_of} & searches for any one of a set of elements \\ \hline
        \hword{adjacent\_find} & finds the first two adjacent items that are equal (or satisfy a given predicate) \\ \hline
        \hword{search} & searches for a range of elements \\ \hline
        \hword{search\_n} & searches a range for a number of consecutive copies of an element \\ \hline
    \end{tabular}
\end{table}

\lstinputlisting[style=cpp]{code/stl/algorithm/non-modifying.cpp}

\subsection{Modifying sequence operations}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    % \renewcommand\arraystretch{1.3}
    % \begin{tabular}{|l|l|}
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{copy} \hword{copy\_if} & copies a range of elements to a new location \\ \hline
        \hword{copy\_n} & copies a number of elements to a new location \\ \hline
        \hword{copy\_backward} & copies a range of elements in backwards order \\ \hline
        \hword{move} & moves a range of elements to a new location \\ \hline
        \hword{move\_backward} & moves a range of elements to a new location in backwards order \\ \hline
        \hword{fill} & copy-assigns the given value to every element in a range \\ \hline
        \hword{fill\_n} & copy-assigns the given value to N elements in a range \\ \hline
        \hword{transform} & assigns the results of successive function calls to every element in a range \\ \hline
        \hword{generate} & assigns the results of successive function calls to every element in a range \\ \hline
        \hword{generate\_n} & assigns the results of successive function calls to N elements in a range \\ \hline
        \hword{remove} \hword{remove\_if} & removes elements satisfying specific criteria \\ \hline
        \hword{remove\_copy} \hword{remove\_copy\_if} & copies a range of elements omitting those that satisfy specific criteria \\ \hline
        \hword{replace} \hword{replace\_if} & replaces all values satisfying specific criteria with another value \\ \hline
        \hword{replace\_copy} \hword{replace\_copy\_if} & copies a range, replacing elements satisfying specific criteria with another value \\ \hline
        \hword{swap} & swaps the values of two objects \\ \hline
        \hword{swap\_ranges} & swaps two ranges of elements \\ \hline
        \hword{iter\_swap} & swaps the elements pointed to by two iterators \\ \hline
        \hword{reverse} & reverses the order of elements in a range \\ \hline
        \hword{reverse\_copy} & creates a copy of a range that is reversed \\ \hline
        \hword{rotate} & rotates the order of elements in a range \\ \hline
        \hword{rotate\_copy} & copies and rotate a range of elements \\ \hline
        \hword{shuffle} & randomly re-orders elements in a range \\ \hline
        \hword{unique} & removes consecutive duplicate elements in a range \\ \hline
        \hword{unique\_copy} & creates a copy of some range of elements that contains no consecutive duplicates \\ \hline
    % \end{tabular}
\end{longtable}
\end{center}


% \section{numeric}
% cmath