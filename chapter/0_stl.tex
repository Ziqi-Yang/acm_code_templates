\chapterimage{chapter_0.png}
\chapter{STL}

\begin{center}
    \pgfornament[width=0.36\linewidth,color=lsp]{88}
\end{center}

\begin{mybox1}
\textbf{备注}： 以c++14为标准
\end{mybox1}

\section{pair}
std::pair 是标准库中定义的一个类模板。用于将两个变量关联在一起，组成一个“对”，而且两个变量的数据类型可以是不同的。
\lstinputlisting[style=cpp]{code/stl/pair.cpp}

\section{vector}
std::vector 是 STL 提供的 内存连续的、可变长度 的数组（亦称列表）数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。
\lstinputlisting[style=cpp]{code/stl/vector.cpp}

\section{array}
std::array 是 STL 提供的 内存连续的、固定长度 的数组数据结构。其本质是对原生数组的直接封装。
\lstinputlisting[style=cpp]{code/stl/array.cpp}

\section{deque}
std::deque 是 STL 提供的 双端队列 数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。
\lstinputlisting[style=cpp]{code/stl/deque.cpp}

\section{list}
std::list 是 STL 提供的 双向链表 数据结构。能够提供线性复杂度的随机访问，以及常数复杂度的插入和删除。

list 的使用方法与 deque 基本相同，但是增删操作和访问的复杂度不同。此处列下特殊的(下列函数list提供了特别的实现以供使用):
\lstinputlisting[style=cpp]{code/stl/list.cpp}

\section{set / unordered\_set}
关于 unordered\_set 的哈希冲突，使用自定义哈希函数可以有效避免构造数据产生的大量哈希冲突，代码实现见本册附录。

set 是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。set 内部通常采用红黑树实现。平衡二叉树的特性使得 set 非常适合处理需要同时兼顾查找、插入与删除的情况。\\
和数学中的集合相似，set 中不会出现值相同的元素。如果需要有相同元素的集合，需要使用 multiset。multiset 的使用方法与 set 的使用方法基本相同。(当然也有unordered\_multiset)
\lstinputlisting[style=cpp]{code/stl/set.cpp}

\section{map / unordered\_map}
关于 unordered\_map 的哈希冲突，使用自定义哈希函数可以有效避免构造数据产生的大量哈希冲突，代码实现见本册附录。

map 是有序键值对容器，它的元素的键是唯一的。搜索、移除和插入操作拥有对数复杂度。map 通常实现为红黑树。multimap则允许有重复的Key值。(当然也有 unordered\_multimap)
\lstinputlisting[style=cpp]{code/stl/map.cpp}

\section{string}
std::string 是在标准库 <string>（注意不是 C 语言中的 <string.h> 库）中提供的一个类，本质上是 std::basic\_string<char> 的别称。

\lstinputlisting[style=cpp]{code/stl/string.cpp}

\section{stack}
STL 栈 (std::stack) 是一种后进先出 (Last In, First Out) 的容器适配器，仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。
\lstinputlisting[style=cpp]{code/stl/stack.cpp}

\section{queue}
STL 队列 (std::queue) 是一种先进先出 (First In, First Out) 的容器适配器，仅支持查询或删除第一个加入的元素（队首元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。
\lstinputlisting[style=cpp]{code/stl/queue.cpp}

\section{priority\_queue}
默认容器为vector, 默认算子为 less, 也就是最大堆
\lstinputlisting[style=cpp]{code/stl/priority_queue.cpp}


\section{bitset}
std::bitset 是标准库中的一个存储 0/1 的大小不可变容器。严格来讲，它并不属于 STL。
\lstinputlisting[style=cpp]{code/stl/bitset.cpp}

\section{iterator}
\lstinputlisting[style=cpp]{code/stl/iterator.cpp}

\section{algorithm}

\subsection{Non-modifying sequence operations}

\begin{center}
\begin{longtable}{ll}
    \caption{Non-modifying sequence operations} \\
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{all\_of} \hword{any\_of} \hword{none\_of} & checks if a predicate is \textbf{true} for all, any or none of the elements in a range \\ \hline
        \hword{for\_each} & 	applies a function to a range of elements \\ \hline
        \hword{count} \hword{count\_if} & returns the number of elements satisfying specific criteria \\ \hline
        \hword{mismatch} & finds the first position where two ranges differ \\ \hline
        \hword{find} \hword{find\_if} \hword{find\_if\_not} & 	finds the first element satisfying specific criteria \\ \hline
        \hword{find\_end} &  finds the last sequence of elements in a certain range \\ \hline
        \hword{find\_first\_of} & searches for any one of a set of elements \\ \hline
        \hword{adjacent\_find} & finds the first two adjacent items that are equal (or satisfy a given predicate) \\ \hline
        \hword{search} & searches for a range of elements \\ \hline
        \hword{search\_n} & searches a range for a number of consecutive copies of an element \\ \hline
\end{longtable}
\end{center}

\lstinputlisting[style=cpp]{code/stl/algorithm/non-modifying.cpp}

\subsection{Modifying sequence operations}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    % \renewcommand\arraystretch{1.3}
    % \begin{tabular}{|l|l|}
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{copy} \hword{copy\_if} & copies a range of elements to a new location \\ \hline
        \hword{copy\_n} & copies a number of elements to a new location \\ \hline
        \hword{copy\_backward} & copies a range of elements in backwards order \\ \hline
        \hword{move} & moves a range of elements to a new location \\ \hline
        \hword{move\_backward} & moves a range of elements to a new location in backwards order \\ \hline
        \hword{fill} & copy-assigns the given value to every element in a range \\ \hline
        \hword{fill\_n} & copy-assigns the given value to N elements in a range \\ \hline
        \hword{transform} & assigns the results of successive function calls to every element in a range \\ \hline
        \hword{generate} & assigns the results of successive function calls to every element in a range \\ \hline
        \hword{generate\_n} & assigns the results of successive function calls to N elements in a range \\ \hline
        \hword{remove} \hword{remove\_if} & removes elements satisfying specific criteria \\ \hline
        \hword{remove\_copy} \hword{remove\_copy\_if} & copies a range of elements omitting those that satisfy specific criteria \\ \hline
        \hword{replace} \hword{replace\_if} & replaces all values satisfying specific criteria with another value \\ \hline
        \hword{replace\_copy} \hword{replace\_copy\_if} & copies a range, replacing elements satisfying specific criteria with another value \\ \hline
        \hword{swap} & swaps the values of two objects \\ \hline
        \hword{swap\_ranges} & swaps two ranges of elements \\ \hline
        \hword{iter\_swap} & swaps the elements pointed to by two iterators \\ \hline
        \hword{reverse} & reverses the order of elements in a range \\ \hline
        \hword{reverse\_copy} & creates a copy of a range that is reversed \\ \hline
        \hword{rotate} & rotates the order of elements in a range \\ \hline
        \hword{rotate\_copy} & copies and rotate a range of elements \\ \hline
        \hword{shuffle} & randomly re-orders elements in a range \\ \hline
        \hword{unique} & removes consecutive duplicate elements in a range \\ \hline
        \hword{unique\_copy} & creates a copy of some range of elements that contains no consecutive duplicates \\ \hline
    % \end{tabular}
\end{longtable}
\end{center}

\lstinputlisting[style=cpp]{code/stl/algorithm/modifying.cpp}

\subsection{Partitioning operations}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{is\_partitioned} & determines if the range is partitioned by the given predicate \\ \hline
        \hword{partition} & divides a range of elements into two groups \\ \hline
        \hword{partition\_copy} & copies a range dividing the elements into two groups \\ \hline
        \hword{stable\_partition} & divides elements into two groups while preserving their relative order \\ \hline
        \hword{partition\_point} & locates the partition point of a partitioned range \\ \hline
\end{longtable}
\end{center}

\subsection{Sorting operations}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{is\_sorted} & checks whether a range is sorted into ascending order \\ \hline
        \hword{is\_sorted\_until} & finds the largest sorted subrange \\ \hline
        \hword{sort} & sorts a range into ascending order \\ \hline
        \hword{partial\_sort} & sorts the first N elements of a range \\ \hline
        \hword{partial\_sort\_copy} & copies and partially sorts a range of elements \\ \hline
        \hword{stable\_sort} & sorts a range of elements while preserving order between equal elements \\ \hline
        \hword{nth\_element} & partially sorts the given range making sure that it is partitioned by the given element \\ \hline
\end{longtable}
\end{center}

\subsection{Binary search operations (on sorted ranges)}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{lower\_bound} & returns an iterator to the first element not less than the given value \\ \hline
        \hword{upper\_bound} & returns an iterator to the first element greater than a certain value \\ \hline
        \hword{binary\_search} & determines if an element exists in a partially-ordered range \\ \hline
        \hword{equal\_range} & returns range of elements matching a specific key \\ \hline
\end{longtable}
\end{center}

\subsection{Other operations on sorted ranges}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{merge} & merges two sorted ranges \\ \hline
        \hword{inplace\_merge} & merges two ordered ranges in-place \\ \hline
\end{longtable}
\end{center}

\subsection{Set operations (on sorted ranges)}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{includes} & returns true if one sequence is a subsequence of another \\ \hline
        \hword{set\_difference} & computes the difference between two sets \\ \hline
        \hword{set\_intersection} & computes the intersection of two sets \\ \hline
        \hword{set\_symmetric\_difference} & computes the symmetric difference between two sets \\ \hline
        \hword{set\_union} & computes the union of two sets \\ \hline
\end{longtable}
\end{center}

\subsection{Heap operations}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{is\_heap} & checks if the given range is a max heap \\ \hline
        \hword{is\_heap\_until} & finds the largest subrange that is a max heap \\ \hline
        \hword{make\_heap} & creates a max heap out of a range of elements \\ \hline
        \hword{push\_heap} & adds an element to a max heap \\ \hline
        \hword{pop\_heap} & removes the largest element from a max heap \\ \hline
        \hword{sort\_heap} & turns a max heap into a range of elements sorted in ascending order \\ \hline
\end{longtable}
\end{center}

\subsection{Minimum/maximum operations}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{max} & returns the greater of the given values \\ \hline
        \hword{max\_element} & returns the largest element in a range \\ \hline
        \hword{min} & returns the smaller of the given values \\ \hline
        \hword{min\_element} & returns the smallest element in a range \\ \hline
        \hword{minmax} & returns the smaller and larger of two elements \\ \hline
        \hword{minmax\_element} & returns the smallest and the largest elements in a range \\ \hline
\end{longtable}
\end{center}

\subsection{Comparison operations}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{equal} & determines if two sets of elements are the same \\ \hline
        \hword{lexicographical\_compare} & returns true if one range is lexicographically less than another \\ \hline
\end{longtable}
\end{center}

\subsection{Permutation operations}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{is\_permutation} & determines if a sequence is a permutation of another sequence \\ \hline
        \hword{next\_permutation} & generates the next greater lexicographic permutation of a range of elements \\ \hline
        \hword{prev\_permutation} & generates the next smaller lexicographic permutation of a range of elements \\ \hline
\end{longtable}
\end{center}

\subsection{Numeric operations}

\begin{center}
\begin{longtable}{ll}
    \caption{Modifying sequence operations} \\
    \hline
        \textbf{operations} & \textbf{ functions } \\ \hline
        \hword{iota} & fills a range with successive increments of the starting value \\ \hline
        \hword{accumulate} & sums up a range of elements \\ \hline
        \hword{inner\_product} & computes the inner product of two ranges of elements \\ \hline
        \hword{adjacent\_difference} & computes the differences between adjacent elements in a range \\ \hline
        \hword{partial\_sum} & computes the partial sum of a range of elements \\ \hline
\end{longtable}
\end{center}

% \subsection{Operations on uninitialized memory}

% \section{numeric}
% cmath